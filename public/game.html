<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Приключения курьера</title>
<style>
  /* --- Сброс и базовые стили --- */
  *, *::before, *::after {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
    font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif;
    background: linear-gradient(#555 10%, #444 50%, #555 90%);
    color: #FFD700;
    user-select: none;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  /* --- Контейнер игры --- */
  #container {
    flex: 1 1 auto;
    width: 100vw;
    max-width: 100vw;
    max-height: 100vh;
    display: flex;
    flex-direction: column;
    background: transparent;
  }

  /* --- Верхняя и нижняя полосы с лесом --- */
  .city-strip {
    flex-shrink: 0;
    height: clamp(3rem, 8vw, 5rem);
    background: linear-gradient(to bottom, #2e7d32, #145214);
    overflow: hidden;
    position: relative;
    font-size: clamp(2rem, 6vw, 3rem);
    line-height: clamp(3rem, 8vw, 5rem);
    white-space: nowrap;
    color: #a5d6a7;
  }
  .scrolling-objects {
    position: absolute;
    top: 0; left: 0;
    height: 100%;
    width: 200%;
    white-space: nowrap;
    animation: scrollLeft 20s linear infinite;
    font-size: clamp(2rem, 6vw, 3rem);
  }
  @keyframes scrollLeft {
    0% { transform: translateX(0); }
    100% { transform: translateX(-50%); }
  }

  /* --- Игровое поле с 5 полосами --- */
  #game {
    flex: 1 1 auto;
    position: relative;
    width: 100%;
    max-width: 100vw;
    height: 100%;
    max-height: calc(100vh - 2 * clamp(3rem, 8vw, 5rem));
    box-shadow: inset 0 0 2vw #222;
    overflow: hidden;

    display: flex;
    flex-direction: column;
    justify-content: space-around;
    padding: 0 1vw;

    background: none;
  }
  .lane {
    flex: 1;
    position: relative;
    border: none;
    background: transparent;
    overflow: visible;
  }
  .lane::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    width: 100%;
    height: 6px;
    background:
      repeating-linear-gradient(
        to right,
        white 0,
        white 20px,
        transparent 20px,
        transparent 40px
      );
    opacity: 0.6;
    transform: translateY(-50%);
    animation: dashMove linear infinite;
    pointer-events: none;
    z-index: 2;
    animation-duration: 1s;
  }
  @keyframes dashMove {
    0% {
      background-position: 0 0;
    }
    100% {
      background-position: -40px 0;
    }
  }

  /* --- Курьер с собакой с анимацией покачивания --- */
  #courier {
    position: absolute;
    left: 10%;
    font-size: clamp(3rem, 8vw, 4rem);
    user-select: none;
    pointer-events: none;
    z-index: 10;
    text-shadow: 1px 1px 0.2vw #2e1b0c;
    transform-origin: center bottom;
    animation: sway 2s ease-in-out infinite;
    width: 1em;
    height: 1em;
    transform-origin: center bottom;
    transform-style: preserve-3d;
    transform-box: fill-box;
    transform: scaleX(-1);
    transition: top 0.15s cubic-bezier(0.4, 0, 0.2, 1);
  }
  @keyframes sway {
    0%, 100% { transform: scaleX(-1) translateX(0) rotate(0deg); }
    25% { transform: scaleX(-1) translateX(-0.1em) rotate(-3deg); }
    50% { transform: scaleX(-1) translateX(0) rotate(0deg); }
    75% { transform: scaleX(-1) translateX(0.1em) rotate(3deg); }
  }
  #dog {
    position: absolute;
    top: 0;
    left: 0.6em;
    font-size: 0.625em;
    opacity: 0.7;
    user-select: none;
    pointer-events: none;
    z-index: 0;
    animation: rideDog 1s ease-in-out infinite;
    transform-origin: center center;
  }
  #helmet {
    position: absolute;
    top: 0.1em;
    left: 0.6em;
    width: 0.2em;
    height: 0.15em;
    background: gold;
    border-radius: 1rem 1rem 0 0;
    box-shadow: inset 0 -0.3rem 0.2rem #cc9f00;
    z-index: 0;
    animation: rideDog 1s ease-in-out infinite;
  }
  #scooter {
    position: relative;
    z-index: 1;
    user-select: none;
    pointer-events: none;
    animation: rideScooter 1s ease-in-out infinite;
    transform-origin: center bottom;
  }
  @keyframes rideScooter {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-0.3rem) rotate(-3deg); }
    50% { transform: translateY(0) rotate(0deg); }
    75% { transform: translateY(-0.3rem) rotate(3deg); }
  }
  @keyframes rideDog {
    0%, 100% { transform: translateY(0); }
    25% { transform: translateY(-0.2rem); }
    50% { transform: translateY(0); }
    75% { transform: translateY(-0.2rem); }
  }

  /* --- Облако речи курьера (адаптивное) --- */
  #speechBubble {
    position: absolute;
    background: #222c;
    color: #fff;
    padding: 0.4rem 0.8rem;
    border-radius: 0.6rem;
    font-size: clamp(0.8rem, 2vw, 1rem);
    max-width: 90vw;
    width: auto;
    pointer-events: none;
    user-select: none;
    opacity: 0;
    transition: opacity 0.3s ease;
    box-shadow: 0 0 0.3rem #000a;
    z-index: 20;
    font-weight: 600;
    white-space: nowrap;
  }
  #speechBubble::after {
    content: "";
    position: absolute;
    bottom: -0.4rem;
    left: 50%;
    transform: translateX(-50%);
    border-width: 0.4rem 0.4rem 0 0.4rem;
    border-style: solid;
    border-color: #222c transparent transparent transparent;
  }

  /* --- Объекты --- */
  .pedestrian, .food, .medkit, .bonus, .policeCar, .policeStanding {
    position: absolute;
    font-size: clamp(2rem, 6vw, 3rem);
    user-select: none;
    pointer-events: none;
    z-index: 5;
    transition: transform 0.2s ease;
    text-shadow: 1px 1px 0.1vw #422d1f;
  }
  .pedestrian {
    filter: drop-shadow(0 0 0.15rem #8b0000);
  }
  .food {
    filter: drop-shadow(0 0 0.2rem #ffd54f);
    text-shadow: 1px 1px 0.1vw #7a4a19;
  }
  .medkit {
    filter: drop-shadow(0 0 0.25rem #e57373);
    text-shadow: 1px 1px 0.1vw #c62828;
  }
  .bonus {
    filter: drop-shadow(0 0 0.25rem #64b5f6);
    text-shadow: 1px 1px 0.1vw #1565c0;
  }
  .policeCar {
    filter: drop-shadow(0 0 0.3rem #2196f3);
    text-shadow: 1px 1px 0.15vw #0d47a1;
  }
  .policeStanding {
    filter: drop-shadow(0 0 0.25rem #1565c0);
    text-shadow: 1px 1px 0.1vw #0d47a1;
  }

  /* --- Главное меню --- */
  #mainMenu {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #000a;
    border-radius: 1rem;
    padding: clamp(1rem, 4vw, 2rem) clamp(2rem, 8vw, 4rem);
    box-shadow: 0 0 1rem #FFD700;
    text-align: center;
    z-index: 1000;
    font-weight: 700;
    user-select: none;
    color: #FFD700;
    max-width: 90vw;
    width: 400px;
  }
  #versionMenu {
    position: absolute;
    bottom: 0.5rem;
    left: 0.5rem;
    font-size: 0.9rem;
    color: #FFD700;
    opacity: 0.7;
    user-select: none;
    pointer-events: none;
  }
  #menuLogo {
    font-weight: 900;
    margin-bottom: 1.5rem;
  }
  #menuLogo .text {
    font-size: clamp(1.5rem, 6vw, 2rem);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.4rem;
  }
  #menuLogo .nd {
    font-size: clamp(2rem, 5vw, 2.4rem);
  }
  #menuCharacter {
    font-size: 3.5rem;
    user-select: none;
    position: relative;
    text-shadow: 1px 1px 0.2vw #2e1b0c;
    animation: sway 2s ease-in-out infinite;
    transform-origin: center bottom;
    transform-style: preserve-3d;
    transform-box: fill-box;
    transform: scaleX(-1);
  }
  #menuCharacter #dog {
    position: absolute;
    top: 0;
    left: 0.6em;
    font-size: 0.625em;
    opacity: 0.7;
    animation: rideDog 1s ease-in-out infinite;
    transform-origin: center center;
  }
  #menuCharacter #helmet {
    position: absolute;
    top: 0.1em;
    left: 0.6em;
    width: 0.2em;
    height: 0.15em;
    background: gold;
    border-radius: 1rem 1rem 0 0;
    box-shadow: inset 0 -0.3rem 0.2rem #cc9f00;
    animation: rideDog 1s ease-in-out infinite;
  }
  #menuCharacter #scooter {
    position: relative;
    z-index: 1;
    animation: rideScooter 1s ease-in-out infinite;
    transform-origin: center bottom;
  }
  #mainMenu button {
    margin: 0.75rem 0;
    font-size: clamp(1rem, 4vw, 1.5rem);
    padding: 0.75rem 2rem;
    border: 2px solid #FFD700;
    border-radius: 0.75rem;
    background-color: transparent;
    color: #FFD700;
    cursor: pointer;
    width: 100%;
    transition: background-color 0.3s, color 0.3s;
  }
  #mainMenu button:hover,
  #mainMenu button:focus {
    background-color: #FFD700;
    color: #000;
    outline: none;
  }
  
  /* Красная кнопка "Подать заявку" */
  #becomeBtn {
    background-color: #dc2626 !important;
    color: #fff !important;
    border-color: #dc2626 !important;
  }
  #becomeBtn:hover,
  #becomeBtn:focus {
    background-color: #b91c1c !important;
    color: #fff !important;
    border-color: #b91c1c !important;
  }

  /* --- Меню после окончания игры --- */
  #gameOverMenu {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #000a;
    border-radius: 1rem;
    padding: clamp(1rem, 4vw, 2rem) clamp(2rem, 8vw, 4rem);
    box-shadow: 0 0 1rem #FFD700;
    text-align: center;
    z-index: 1100;
    font-size: clamp(1.2rem, 4vw, 1.5rem);
    font-weight: 700;
    user-select: none;
    color: #FFD700;
    display: none;
    max-width: 90vw;
    width: 320px;
  }
  #gameOverMenu button {
    margin: 0.75rem 0.5rem 0 0.5rem;
    font-size: clamp(1rem, 4vw, 1.25rem);
    padding: 0.5rem 1.5rem;
    border: 2px solid #FFD700;
    border-radius: 0.6rem;
    background-color: transparent;
    color: #FFD700;
    cursor: pointer;
    transition: background-color 0.3s, color 0.3s;
  }
  #gameOverMenu button:hover,
  #gameOverMenu button:focus {
    background-color: #FFD700;
    color: #000;
    outline: none;
  }

  /* --- Информация внизу --- */
  #info {
    position: fixed;
    bottom: 1vh;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255 255 255 / 0.85);
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-weight: 600;
    font-size: clamp(0.8rem, 3vw, 1.2rem);
    color: #3e2723;
    box-shadow: 0 0 0.5rem rgba(0,0,0,0.2);
    user-select: none;
    z-index: 20;
    max-width: 95vw;
    text-align: center;
    line-height: 1.2;
    display: none;
  }

  /* --- Жизни --- */
  #lives {
    position: fixed;
    top: 1vh;
    left: 1vw;
    font-size: clamp(1.5rem, 5vw, 2.5rem);
    user-select: none;
    z-index: 30;
    color: #FFD700;
    text-shadow: 0 0 0.4rem #FFA500;
    display: none;
  }

  /* --- Сенсорные кнопки управления слева и справа снизу --- */
  #touchControls {
    position: fixed;
    bottom: 1vh;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    padding: 0 1rem;
    z-index: 30;
    user-select: none;
    pointer-events: auto;
    max-width: 100vw;
    box-sizing: border-box;
    display: none;
  }
  .touchBtn {
    background: rgba(255 215 0, 0.7);
    border: none;
    border-radius: 1rem;
    width: clamp(3rem, 15vw, 5rem);
    height: clamp(3rem, 15vw, 5rem);
    font-size: clamp(1.5rem, 8vw, 3rem);
    color: #000;
    cursor: pointer;
    box-shadow: 0 0 1rem #FFD700;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: background-color 0.3s;
  }
  .touchBtn:active {
    background: rgba(255 215 0, 0.9);
  }
  @media (min-width: 768px) {
    #touchControls {
      display: none !important;
    }
  }
  @media (max-width: 767px) {
    #touchControls {
      display: flex;
    }
  }

  /* --- Экран приветствия с желтой рамкой --- */
  #welcomeScreen {
    position: fixed;
    inset: 0;
    background: black;
    color: #FFD700;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    user-select: none;
    z-index: 3000;
    padding: 1rem;
    text-align: center;

    /* Желтая адаптивная рамка */
    box-sizing: border-box;
    border: 0.5vw solid #FFD700;
    border-radius: 2vw;
  }
  #welcomeScreen h1 {
    font-size: clamp(3rem, 15vw, 6rem);
    font-weight: 900;
    text-shadow: 0 0 1rem #FFD700, 0 0 2rem #FFA500;
    animation: blinkYellow 1s linear infinite alternate;
  }
  #welcomeScreen .subtitle {
    font-size: clamp(2rem, 8vw, 3rem);
    margin-top: 0.2em;
    font-weight: 700;
    text-shadow: 0 0 0.8rem #FFD700;
    animation: blinkYellow 1s linear infinite alternate;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.3rem;
  }
  #welcomeScreen .subtitle strong {
    font-weight: 900;
  }
  #welcomeCharacter {
    font-size: 3.5rem;
    user-select: none;
    position: relative;
    text-shadow: 1px 1px 0.2vw #2e1b0c;
    animation: sway 2s ease-in-out infinite;
    transform-origin: center bottom;
    transform-style: preserve-3d;
    transform-box: fill-box;
    transform: scaleX(-1);
  }
  #welcomeCharacter #dog {
    position: absolute;
    top: 0;
    left: 0.6em;
    font-size: 0.625em;
    opacity: 0.7;
    animation: rideDog 1s ease-in-out infinite;
    transform-origin: center center;
  }
  #welcomeCharacter #helmet {
    position: absolute;
    top: 0.1em;
    left: 0.6em;
    width: 0.2em;
    height: 0.15em;
    background: gold;
    border-radius: 1rem 1rem 0 0;
    box-shadow: inset 0 -0.3rem 0.2rem #cc9f00;
    animation: rideDog 1s ease-in-out infinite;
  }
  #welcomeCharacter #scooter {
    position: relative;
    z-index: 1;
    animation: rideScooter 1s ease-in-out infinite;
    transform-origin: center bottom;
  }
  @keyframes blinkYellow {
    0% { opacity: 1; }
    100% { opacity: 0.3; }
  }

  /* --- Экран ПОТРАЧЕНО --- */
  #gtaGameOverScreen {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.85);
    color: #ff0000;
    font-size: clamp(6rem, 20vw, 12rem);
    font-weight: 900;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    user-select: none;
    z-index: 4000;
    text-shadow:
      -2px -2px 0 #000,
      2px -2px 0 #000,
      -2px 2px 0 #000,
      2px 2px 0 #000;
    font-family: 'Impact', 'Arial Black', sans-serif;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    opacity: 0;
    animation: gtaFadeInOut 5s forwards;
    writing-mode: horizontal-tb;
    padding: 0 1rem;
    white-space: nowrap;
    overflow-wrap: normal;
    overflow-x: auto;
    display: none;
  }
  @media (max-width: 480px), (max-height: 700px) {
    #gtaGameOverScreen {
      font-size: clamp(3rem, 15vw, 6rem);
      letter-spacing: 0.05em;
      padding: 0 0.5rem;
      white-space: normal;
      overflow-x: visible;
      word-break: break-word;
    }
  }
  @keyframes gtaFadeInOut {
    0% {
      opacity: 0;
      transform: scale(0.7);
    }
    20% {
      opacity: 1;
      transform: scale(1);
    }
    80% {
      opacity: 1;
      transform: scale(1);
    }
    100% {
      opacity: 0;
      transform: scale(0.7);
    }
  }

  /* --- Поднимаем кепочку на мобильных во всех местах --- */
  @media (max-width: 767px) {
    #helmet {
      top: 0.0em !important;
      height: 0.18em !important;
      width: 0.22em !important;
      box-shadow: inset 0 -0.35rem 0.25rem #cc9f00 !important;
    }
  }
</style>
</head>
<body>

<!-- Экран приветствия -->
<div id="welcomeScreen" role="alert" aria-live="assertive" aria-label="Приветственный экран игры">
  <h1>Приключения курьера</h1>
  <div class="subtitle">
    <div id="welcomeCharacter" aria-label="Персонаж курьера корги" role="img" style="display:inline-block; margin-left:0.3rem;">
      <img src="https://cdn.poehali.dev/files/d91aa39a-b906-481f-95ef-6c750cb6a76a.png" alt="Курьер корги" style="width:80px; height:80px; object-fit:contain; animation: bounce 2s infinite ease-in-out;" />
    </div>
  </div>
</div>

<!-- Главное меню -->
<div id="mainMenu" role="menu" aria-label="Главное меню игры" tabindex="0" style="display:none;">
  <div id="menuLogo" aria-label="Логотип игры" style="margin-bottom: 1.5rem;">
    <div class="nd">Приключения курьера</div>
    <div class="text">
      <div id="menuCharacter" aria-label="Персонаж курьера корги" role="img" style="display:inline-block; margin-left:0.3rem;">
        <img src="https://cdn.poehali.dev/files/d91aa39a-b906-481f-95ef-6c750cb6a76a.png" alt="Курьер корги" style="width:80px; height:80px; object-fit:contain; animation: bounce 2s infinite ease-in-out;" />
      </div>
    </div>
  </div>
  <button id="playBtn" role="menuitem">Играть</button>
  <button id="rulesBtn" role="menuitem">Правила</button>
  <button id="becomeBtn" role="menuitem" style="background-color: #dc2626 !important; color: #fff !important; border-color: #dc2626 !important;">Подать заявку</button>
  <button id="exitBtn" role="menuitem">Выход из игры</button>

</div>

<!-- Правила -->
<div id="rulesDialog" role="dialog" aria-modal="true" aria-labelledby="rulesTitle" style="display:none; color:#fff; background:#000; padding:1rem; border-radius:1rem; max-width:600px; margin: 4vh auto; overflow-y:auto; max-height: 80vh; position: fixed; inset: 0; z-index: 2000;">
  <h2 id="rulesTitle" style="color:#FFD700; text-align:center; margin-bottom: 0.5rem;">Правила игры</h2>
  <ul style="line-height:1.5; font-size: 1.1rem; padding-left: 1.2rem;">
    <li>Управляйте курьером (🛵) стрелками ↑ и ↓ или касаниями на экране.</li>
    <li>Курьер может перемещаться по пяти полосам движения, меняя позицию вверх/вниз.</li>
    <li>Собирайте еду (🍕, 🍔, 🍟, 🌭, 🍗, 🌮) для очков.</li>
    <li>Разные виды фаст-фуда дают разное количество очков.</li>
    <li>Появляются аптечки (🩹), которые восстанавливают жизнь.</li>
    <li>Избегайте пешеходов и полицейских — столкновения отнимают жизни:</li>
    <ul style="font-size: 1rem; padding-left: 1rem;">
      <li>Стоячий пешеход (🧍) отнимает 0.5 ❤️.</li>
      <li>Идущие пешеходы (🚶‍♂️, 🚶‍♀️) отнимают 1 ❤️.</li>
      <li>Стоячий полицейский (👮‍♂️) отнимает 1.5 ❤️.</li>
      <li>Полицейская машина с полицейским (🚓👮‍♂️) отнимает 2 ❤️.</li>
    </ul>
    <li>Появляются бонусы: ускорение (⚡️) и неуязвимость (🛡️).</li>
    <li>Удерживайте стрелки или сенсорные кнопки для плавного движения по полосам.</li>
    <li>Игра усложняется со временем — скорость объектов увеличивается.</li>
    <li>Собирайте комбо еды для дополнительных очков.</li>
    <li>Игра заканчивается, когда жизни заканчиваются.</li>
  </ul>
  <button id="closeRulesBtn" style="background:#FFD700; border:none; border-radius:1rem; padding:0.75rem 2rem; font-weight:700; cursor:pointer; color:#000; display:block; margin:1rem auto 0 auto;">Закрыть</button>
</div>

<div id="container" role="main" aria-label="Игровое поле с дорожкой и лесом" style="display:none;">

  <div class="city-strip" aria-hidden="true">
    <div class="scrolling-objects" aria-hidden="true" id="topObjects" tabindex="-1" aria-hidden="true">
      🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳
      🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳
    </div>
  </div>

  <div id="game" aria-label="Дорожка с движением" style="position:relative;">
    <div class="lane lane0"></div>
    <div class="lane lane1"></div>
    <div class="lane lane2"></div>
    <div class="lane lane3"></div>
    <div class="lane lane4"></div>

    <div id="courier" aria-label="Курьер корги на велосипеде" role="img" aria-live="polite">
      <img src="https://cdn.poehali.dev/files/d91aa39a-b906-481f-95ef-6c750cb6a76a.png" alt="Курьер корги" style="width:100px; height:100px; object-fit:contain; animation: bounce 1s infinite ease-in-out; transform: scaleX(-1);" />
    </div>
    <div id="speechBubble" aria-live="polite" role="alert"></div>
  </div>

  <div class="city-strip" aria-hidden="true">
    <div class="scrolling-objects" aria-hidden="true" id="bottomObjects" tabindex="-1" aria-hidden="true">
      🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲
      🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲🌳🌲
    </div>
  </div>



</div>

<!-- Информация -->
<div id="info" aria-live="polite" style="display:none;">
  Очки: <span id="score">0</span> | Жизни: <span id="lifeCount">3</span> | Время: <span id="timer">0</span> сек<br>
  Управляйте стрелками ↑ и ↓, чтобы двигаться по полосам.
</div>

<!-- Жизни -->
<div id="lives" aria-label="Жизни игрока" role="img" aria-live="polite" style="display:none;">
  ❤️❤️❤️
</div>

<!-- Меню после окончания игры -->
<div id="gameOverMenu" role="dialog" aria-modal="true" aria-labelledby="gameOverTitle" style="display:none;">
  <div id="gameOverTitle" style="margin-bottom: 12px;">Игра окончена!</div>
  <div>Ваш счёт: <span id="finalScore">0</span></div>
  <button id="restartBtn">Заново</button>
  <button id="toMenuBtn">В меню</button>
</div>

<!-- Экран ПОТРАЧЕНО -->
<div id="gtaGameOverScreen" role="alert" aria-live="assertive" aria-label="Игра окончена - Потрачено" style="display:none;">
  ПОТРАЧЕНО
</div>

<!-- Сенсорное управление -->
<div id="touchControls" aria-label="Управление для сенсорного экрана" role="group" style="display:none;">
  <button id="btnUp" aria-label="Вверх" class="touchBtn">▲</button>
  <button id="btnDown" aria-label="Вниз" class="touchBtn">▼</button>
</div>

<script>
(() => {
  // Элементы
  const welcomeScreen = document.getElementById('welcomeScreen');
  const mainMenu = document.getElementById('mainMenu');
  const rulesDialog = document.getElementById('rulesDialog');
  const gameOverMenu = document.getElementById('gameOverMenu');
  const container = document.getElementById('container');
  const info = document.getElementById('info');
  const courier = document.getElementById('courier');
  const scoreElem = document.getElementById('score');
  const finalScoreElem = document.getElementById('finalScore');
  const livesElem = document.getElementById('lives');
  const lifeCountElem = document.getElementById('lifeCount');
  const btnUp = document.getElementById('btnUp');
  const btnDown = document.getElementById('btnDown');
  const gtaGameOverScreen = document.getElementById('gtaGameOverScreen');
  const touchControls = document.getElementById('touchControls');
  const playBtn = document.getElementById('playBtn');
  const rulesBtn = document.getElementById('rulesBtn');
  const exitBtn = document.getElementById('exitBtn');
  const closeRulesBtn = document.getElementById('closeRulesBtn');
  const restartBtn = document.getElementById('restartBtn');
  const toMenuBtn = document.getElementById('toMenuBtn');
  const becomeBtn = document.getElementById('becomeBtn');
  const game = document.getElementById('game');
  const speechBubble = document.getElementById('speechBubble');
  const lanes = document.querySelectorAll('.lane');

  // Определяем мобильное устройство (по ширине экрана)
  const isMobile = window.innerWidth <= 767;

  // Переменные
  let score = 0;
  let lives = 3;
  let gameOverFlag = false;
  let paused = false;
  let gameTime = 0;
  let comboCount = 0;
  let comboTimeout = null;
  const maxSpeedX = isMobile ? 7 : 12;
  let speedX = isMobile ? 3 : 4;

  let lanePositions = [];
  let courierLane = 2;
  let courierCurrentY = 0;
  let courierTargetLane = 2;

  // Управление движением
  let movingUp = false;
  let movingDown = false;

  let pedestrians = [];
  let standingPeds = [];
  let policeStandings = [];
  let foods = [];
  let medkits = [];
  let bonuses = [];
  let policeCars = [];

  let pedestrianSpawnTimer;
  let standingPedSpawnTimer;
  let policeStandingSpawnTimer;
  let foodSpawnTimer;
  let medkitSpawnTimer;
  let bonusSpawnTimer;
  let policeCarSpawnTimer;
  let gameLoopId;
  let lastFrameTime = 0;
  let timerInterval;

  let shieldActive = false;
  let speedBoostActive = false;
  let speedBoostTimeout = null;
  let shieldTimeout = null;

  const pedestrianPhrases = [
    "Опа, живые препятствия на маршруте!",
    "Пешеходы! Врубай режим ниндзя!",
    "Люди идут — газ в пол, брат!",
    "Смотри, тут толпа! Вжух — и мы уже в другом месте!",
    "Пешеходы — главные тормоза жизни!",
    "Осторожно, ходячие кегли!",
    "Пешеходы! Время для танцев на скутере!",
    "Люди идут, как будто я им должен!",
    "Пешеходы — бесплатный квест на скорость!",
    "Ха! Пешеходы, вы меня не догоните!",
    "Пешеходы — главная угроза моему стилю!",
    "Живые пробки на колесах!",
    "Пешеходы идут — значит, время для трюков!",
    "Пешеходы — это просто живые препятствия, которые надо объехать!",
    "Пешеходы! Время для паркура на скутере!"
  ];
  const policePhrases = [
    "Опа, мусора на горизонте! Вжух — и нет меня!",
    "Копы едут, пора делать ноги, как в фильмах!",
    "Мусора! Врубай турбо, не тормози!",
    "Полиция на хвосте, надо улизнуть как ниндзя!",
    "Вот и мусора, время для супер-манёвра!",
    "Копы идут — притворюсь невидимкой!",
    "Мусора близко, пора включать режим «призрак»!",
    "Полиция в зоне, давай-ка по-быстрее!",
    "Копы на хвосте — включаю режим «Стью»!",
    "Мусора на дороге? Пошли, я их обгоню!",
    "Полиция в радиусе — включаем режим «Stuey.Go»!",
    "Мусора идут, надо сделать вид, что я просто пицца!",
    "Копы на хвосте, надо срочно на перекус!",
    "Полиция — не повод для паники, а для скорости!",
    "Мусора в зоне видимости, включаем режим «невидимка»!"
  ];

  let lastSpeechTime = 0;
  const speechCooldown = 4000; // 4 секунды между речами

  // Задержка смены полосы при удержании
  let moveCooldown = 0;

  // Для показа речи
  let speechTimeout = null;

  // --- Функции ---

  function recalcLanes() {
    lanePositions = [];
    const laneCount = 5;
    const gameRect = game.getBoundingClientRect();
    for(let i=0; i<laneCount; i++) {
      lanePositions.push(gameRect.top + gameRect.height * ((i + 0.5) / laneCount));
    }
    courierCurrentY = lanePositions[courierLane] - courier.offsetHeight / 2;
    courier.style.top = courierCurrentY + 'px';

    [...pedestrians, ...standingPeds, ...policeStandings, ...foods, ...medkits, ...bonuses, ...policeCars].forEach(obj => {
      const lane = obj.lane;
      if (lanePositions[lane]) {
        obj.elem.style.top = (lanePositions[lane] - obj.elem.offsetHeight / 2) + 'px';
      }
    });
  }

  function updateCourierPositionSmooth() {
    const targetY = lanePositions[courierTargetLane] - courier.offsetHeight / 2;
    let diff = targetY - courierCurrentY;
    if (Math.abs(diff) < 1) {
      courierCurrentY = targetY;
      courierLane = courierTargetLane;
    } else {
      courierCurrentY += diff * 0.25;
    }
    courier.style.top = courierCurrentY + 'px';
  }

  // Создание объектов
  function createPedestrian() {
    if (gameOverFlag) return;
    const ped = document.createElement('div');
    ped.classList.add('pedestrian');
    const lane = Math.floor(Math.random() * 5);
    ped.dataset.lane = lane;
    ped.style.top = (lanePositions[lane] - 24) + 'px';
    ped.style.left = window.innerWidth + 'px';
    const pedestrianEmojis = ['🚶‍♂️', '🚶‍♀️'];
    ped.textContent = pedestrianEmojis[Math.floor(Math.random() * pedestrianEmojis.length)];
    game.appendChild(ped);
    const speedFactor = 0.8 + Math.random() * 0.4;
    pedestrians.push({ elem: ped, x: window.innerWidth, lane, speed: speedX * speedFactor });
  }
  function createStandingPedestrian() {
    if (gameOverFlag) return;
    const ped = document.createElement('div');
    ped.classList.add('pedestrian');
    const lane = Math.floor(Math.random() * 5);
    ped.dataset.lane = lane;
    ped.style.top = (lanePositions[lane] - 24) + 'px';
    ped.style.left = window.innerWidth + 'px';
    ped.textContent = '🧍';
    game.appendChild(ped);
    standingPeds.push({ elem: ped, x: window.innerWidth, lane, speed: speedX * 0.5 });
  }
  function createPoliceStanding() {
    if (gameOverFlag) return;
    const cop = document.createElement('div');
    cop.classList.add('policeStanding');
    const lane = Math.floor(Math.random() * 5);
    cop.dataset.lane = lane;
    cop.style.top = (lanePositions[lane] - 24) + 'px';
    cop.style.left = window.innerWidth + 'px';
    cop.textContent = '👮‍♂️';
    game.appendChild(cop);
    policeStandings.push({ elem: cop, x: window.innerWidth, lane, speed: speedX * 0.5 });
  }
  function createFood() {
    if (gameOverFlag) return;
    const food = document.createElement('div');
    food.classList.add('food');
    const lane = Math.floor(Math.random() * 5);
    food.dataset.lane = lane;
    food.style.top = (lanePositions[lane] - 24) + 'px';
    food.style.left = window.innerWidth + 'px';
    const foodItems = [
      { emoji: '🍕', points: 10 },
      { emoji: '🍔', points: 8 },
      { emoji: '🍟', points: 7 },
      { emoji: '🌭', points: 6 },
      { emoji: '🍗', points: 9 },
      { emoji: '🌮', points: 11 }
    ];
    const item = foodItems[Math.floor(Math.random() * foodItems.length)];
    food.textContent = item.emoji;
    game.appendChild(food);
    foods.push({ elem: food, x: window.innerWidth, lane, points: item.points, speed: speedX });
  }
  function createMedkit() {
    if (gameOverFlag) return;
    const medkit = document.createElement('div');
    medkit.classList.add('medkit');
    const lane = Math.floor(Math.random() * 5);
    medkit.dataset.lane = lane;
    medkit.style.top = (lanePositions[lane] - 24) + 'px';
    medkit.style.left = window.innerWidth + 'px';
    medkit.textContent = '🩹';
    game.appendChild(medkit);
    medkits.push({ elem: medkit, x: window.innerWidth, lane, speed: speedX });
  }
  function createBonus() {
    if (gameOverFlag) return;
    const bonus = document.createElement('div');
    bonus.classList.add('bonus');
    const lane = Math.floor(Math.random() * 5);
    bonus.dataset.lane = lane;
    bonus.style.top = (lanePositions[lane] - 24) + 'px';
    bonus.style.left = window.innerWidth + 'px';
    const bonusesArr = ['⚡️', '🛡️'];
    bonus.textContent = bonusesArr[Math.floor(Math.random() * bonusesArr.length)];
    game.appendChild(bonus);
    bonuses.push({ elem: bonus, x: window.innerWidth, lane, speed: speedX, type: bonus.textContent });
  }
  function createPoliceCar() {
    if (gameOverFlag) return;
    const car = document.createElement('div');
    car.classList.add('policeCar');
    const lane = Math.floor(Math.random() * 5);
    car.dataset.lane = lane;
    car.style.top = (lanePositions[lane] - 24) + 'px';
    car.style.left = window.innerWidth + 'px';
    car.textContent = '🚓👮‍♂️';
    game.appendChild(car);
    policeCars.push({ elem: car, x: window.innerWidth, lane, speed: speedX * 1.5 });
  }

  function updateObjects(delta) {
    // Все объекты движутся влево с учетом delta и скорости
    function moveArray(arr) {
      for(let i=arr.length-1; i>=0; i--) {
        let obj = arr[i];
        obj.x -= obj.speed * delta;
        if (obj.x < -50) {
          obj.elem.remove();
          arr.splice(i,1);
        } else {
          obj.elem.style.left = obj.x + 'px';
        }
      }
    }
    moveArray(pedestrians);
    moveArray(standingPeds);
    moveArray(policeStandings);
    moveArray(foods);
    moveArray(medkits);
    moveArray(bonuses);
    moveArray(policeCars);
  }

  function checkCollisions() {
    if (gameOverFlag) return;

    const courierRect = courier.getBoundingClientRect();

    function isCollide(r1, r2) {
      return !(r2.left > r1.right || 
               r2.right < r1.left || 
               r2.top > r1.bottom ||
               r2.bottom < r1.top);
    }

    for(let i=pedestrians.length-1; i>=0; i--) {
      let p = pedestrians[i];
      if (p.lane === courierLane) {
        const r = p.elem.getBoundingClientRect();
        if (isCollide(courierRect, r)) {
          if (!shieldActive) {
            loseLife(1);
            showSpeechRandom(pedestrianPhrases);
            playSound('hit');
          }
          p.elem.remove();
          pedestrians.splice(i, 1);
          return;
        }
      }
    }
    for(let i=standingPeds.length-1; i>=0; i--) {
      let p = standingPeds[i];
      if (p.lane === courierLane) {
        const r = p.elem.getBoundingClientRect();
        if (isCollide(courierRect, r)) {
          if (!shieldActive) {
            loseLife(0.5);
            showSpeechRandom(pedestrianPhrases);
            playSound('hit');
          }
          p.elem.remove();
          standingPeds.splice(i, 1);
          return;
        }
      }
    }
    for(let i=policeStandings.length-1; i>=0; i--) {
      let p = policeStandings[i];
      if (p.lane === courierLane) {
        const r = p.elem.getBoundingClientRect();
        if (isCollide(courierRect, r)) {
          if (!shieldActive) {
            loseLife(1.5);
            showSpeechRandom(policePhrases);
            playSound('hit');
          }
          p.elem.remove();
          policeStandings.splice(i, 1);
          return;
        }
      }
    }
    for(let i=policeCars.length-1; i>=0; i--) {
      let p = policeCars[i];
      if (p.lane === courierLane) {
        const r = p.elem.getBoundingClientRect();
        if (isCollide(courierRect, r)) {
          if (!shieldActive) {
            loseLife(2);
            showSpeechRandom(policePhrases);
            playSound('hit');
          }
          p.elem.remove();
          policeCars.splice(i, 1);
          return;
        }
      }
    }
    for(let i=foods.length-1; i>=0; i--) {
      let f = foods[i];
      if (f.lane === courierLane) {
        const r = f.elem.getBoundingClientRect();
        if (isCollide(courierRect, r)) {
          score += f.points;
          comboCount++;
          if (comboTimeout) clearTimeout(comboTimeout);
          comboTimeout = setTimeout(() => {
            comboCount = 0;
          }, 3000);
          if (comboCount > 1) {
            score += comboCount * 2;
          }
          updateScoreDisplay();
          f.elem.remove();
          foods.splice(i, 1);
          playSound('eat');
          return;
        }
      }
    }
    for(let i=medkits.length-1; i>=0; i--) {
      let m = medkits[i];
      if (m.lane === courierLane) {
        const r = m.elem.getBoundingClientRect();
        if (isCollide(courierRect, r)) {
          if (lives < 3) {
            lives = Math.min(3, lives + 1);
            updateLivesDisplay();
            playSound('medkit');
          }
          m.elem.remove();
          medkits.splice(i, 1);
          return;
        }
      }
    }
    for(let i=bonuses.length-1; i>=0; i--) {
      let b = bonuses[i];
      if (b.lane === courierLane) {
        const r = b.elem.getBoundingClientRect();
        if (isCollide(courierRect, r)) {
          if (b.type === '⚡️') {
            activateSpeedBoost();
            playSound('bonus');
          } else if (b.type === '🛡️') {
            activateShield();
            playSound('bonus');
          }
          b.elem.remove();
          bonuses.splice(i, 1);
          return;
        }
      }
    }
  }

  function loseLife(amount) {
    if (shieldActive) return;
    lives -= amount;
    if (lives < 0) lives = 0;
    updateLivesDisplay();
    if (lives <= 0) {
      gameOver();
    }
  }

  function updateScoreDisplay() {
    scoreElem.textContent = Math.floor(score);
  }
  function updateLivesDisplay() {
    lifeCountElem.textContent = lives.toFixed(1);
    const fullHearts = Math.floor(lives);
    const halfHeart = (lives % 1) >= 0.5 ? 1 : 0;
    let heartsStr = '';
    for(let i=0; i<fullHearts; i++) heartsStr += '❤️';
    if (halfHeart) heartsStr += '💔';
    livesElem.textContent = heartsStr || '💀';
  }

  function showSpeech(text) {
    if (speechTimeout) clearTimeout(speechTimeout);
    speechBubble.textContent = text;
    speechBubble.style.opacity = '1';
    const rect = courier.getBoundingClientRect();
    speechBubble.style.top = (rect.top - speechBubble.offsetHeight - 5) + 'px';
    speechBubble.style.left = (rect.left + courier.offsetWidth + 10) + 'px';

    speechTimeout = setTimeout(() => {
      speechBubble.style.opacity = '0';
    }, 3000);
  }
  function showSpeechRandom(arr) {
    const text = arr[Math.floor(Math.random() * arr.length)];
    showSpeech(text);
  }

  function activateSpeedBoost() {
    if (speedBoostActive) {
      clearTimeout(speedBoostTimeout);
    } else {
      speedBoostActive = true;
      speedX = Math.min(maxSpeedX, speedX + (isMobile ? 2 : 4));
      updateDashSpeed();
      showSpeech('⚡️ Ускорение!');
    }
    speedBoostTimeout = setTimeout(() => {
      speedBoostActive = false;
      speedX = Math.max(isMobile ? 3 : 4, speedX - (isMobile ? 2 : 4));
      updateDashSpeed();
      showSpeech('⚡️ Ускорение прошло');
    }, 7000);
  }
  function activateShield() {
    if (shieldActive) {
      clearTimeout(shieldTimeout);
    } else {
      shieldActive = true;
      showSpeech('🛡️ Щит активирован!');
      courier.style.filter = 'drop-shadow(0 0 10px #64b5f6)';
    }
    shieldTimeout = setTimeout(() => {
      shieldActive = false;
      showSpeech('🛡️ Щит исчез');
      courier.style.filter = '';
    }, 7000);
  }

  // Система звуков
  let audioContext;
  let backgroundMusicGain;
  let backgroundMusicOscillator;
  let isBackgroundMusicPlaying = false;
  
  const melody = [
    // Более энергичная и увлекательная мелодия для игры курьера
    440.00, // A4
    523.25, // C5  
    659.25, // E5
    783.99, // G5
    880.00, // A5
    783.99, // G5
    659.25, // E5
    698.46, // F5
    659.25, // E5
    587.33, // D5
    523.25, // C5
    587.33, // D5
    659.25, // E5
    523.25, // C5
    440.00, // A4
    493.88, // B4
  ];
  
  const bassLine = [
    // Басовая линия для ритма
    220.00, // A3
    261.63, // C4
    329.63, // E4
    392.00, // G4
    220.00, // A3
    261.63, // C4
    329.63, // E4
    349.23, // F4
  ];
  let currentNoteIndex = 0;
  let nextNoteTime = 0;
  let musicScheduler;
  
  function initAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      backgroundMusicGain = audioContext.createGain();
      backgroundMusicGain.connect(audioContext.destination);
      backgroundMusicGain.gain.value = 0.15; // Чуть громче для большей вовлеченности
    }
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
  }
  
  function createSound(frequency, duration, type = 'sine', volume = 0.3) {
    if (!audioContext) initAudioContext();
    
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.frequency.value = frequency;
    oscillator.type = type;
    
    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
  }
  
  function playBackgroundMusic() {
    if (!audioContext || isBackgroundMusicPlaying) return;
    initAudioContext();
    
    isBackgroundMusicPlaying = true;
    nextNoteTime = audioContext.currentTime;
    currentNoteIndex = 0;
    
    function scheduleNote() {
      if (!isBackgroundMusicPlaying) return;
      
      while (nextNoteTime < audioContext.currentTime + 0.1) {
        const oscillator = audioContext.createOscillator();
        const noteGain = audioContext.createGain();
        
        oscillator.connect(noteGain);
        noteGain.connect(backgroundMusicGain);
        
        const frequency = melody[currentNoteIndex % melody.length];
        oscillator.frequency.value = frequency;
        oscillator.type = 'triangle'; // Более мягкий звук
        
        noteGain.gain.setValueAtTime(0, nextNoteTime);
        noteGain.gain.linearRampToValueAtTime(0.12, nextNoteTime + 0.05);
        noteGain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + 0.4);
        
        oscillator.start(nextNoteTime);
        oscillator.stop(nextNoteTime + 0.5);
        
        // Добавляем гармонию (октава выше)
        if (currentNoteIndex % 2 === 0) {
          const harmonyOsc = audioContext.createOscillator();
          const harmonyGain = audioContext.createGain();
          
          harmonyOsc.connect(harmonyGain);
          harmonyGain.connect(backgroundMusicGain);
          
          harmonyOsc.frequency.value = frequency * 2; // Октава выше
          harmonyOsc.type = 'sine';
          
          harmonyGain.gain.setValueAtTime(0, nextNoteTime);
          harmonyGain.gain.linearRampToValueAtTime(0.06, nextNoteTime + 0.05);
          harmonyGain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + 0.3);
          
          harmonyOsc.start(nextNoteTime);
          harmonyOsc.stop(nextNoteTime + 0.4);
        }
        
        // Добавляем басовую линию каждые 4 ноты
        if (currentNoteIndex % 4 === 0) {
          const bassOsc = audioContext.createOscillator();
          const bassGain = audioContext.createGain();
          
          bassOsc.connect(bassGain);
          bassGain.connect(backgroundMusicGain);
          
          const bassNote = bassLine[Math.floor(currentNoteIndex / 4) % bassLine.length];
          bassOsc.frequency.value = bassNote;
          bassOsc.type = 'square';
          
          bassGain.gain.setValueAtTime(0, nextNoteTime);
          bassGain.gain.linearRampToValueAtTime(0.08, nextNoteTime + 0.02);
          bassGain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + 0.6);
          
          bassOsc.start(nextNoteTime);
          bassOsc.stop(nextNoteTime + 0.7);
        }
        
        const secondsPerBeat = 60.0 / 140; // 140 BPM - более быстрый темп
        nextNoteTime += secondsPerBeat;
        currentNoteIndex++;
      }
      
      if (isBackgroundMusicPlaying) {
        musicScheduler = setTimeout(scheduleNote, 25);
      }
    }
    
    scheduleNote();
  }
  
  function stopBackgroundMusic() {
    isBackgroundMusicPlaying = false;
    if (musicScheduler) {
      clearTimeout(musicScheduler);
      musicScheduler = null;
    }
  }
  
  function playSound(name) {
    if (!audioContext) initAudioContext();
    
    try {
      switch (name) {
        case 'eat':
          createSound(800, 0.15, 'square', 0.4);
          setTimeout(() => createSound(1200, 0.1, 'sine', 0.3), 50);
          break;
        case 'medkit':
          createSound(523, 0.2, 'sine', 0.4);
          setTimeout(() => createSound(659, 0.2, 'sine', 0.4), 100);
          setTimeout(() => createSound(784, 0.3, 'sine', 0.4), 200);
          break;
        case 'hit':
          createSound(200, 0.3, 'sawtooth', 0.5);
          break;
        case 'gameOver':
          createSound(440, 0.3, 'sawtooth', 0.6);
          setTimeout(() => createSound(330, 0.3, 'sawtooth', 0.6), 300);
          setTimeout(() => createSound(262, 0.5, 'sawtooth', 0.6), 600);
          break;
        case 'bonus':
          createSound(1200, 0.1, 'sine', 0.4);
          setTimeout(() => createSound(1600, 0.15, 'triangle', 0.3), 50);
          break;
        default:
          createSound(440, 0.1, 'sine', 0.3);
      }
    } catch (error) {
      console.warn('Sound playback failed:', error);
    }
  }

  function startSpawning() {
    pedestrianSpawnTimer = setInterval(createPedestrian, 2200);
    standingPedSpawnTimer = setInterval(createStandingPedestrian, 2500);
    policeStandingSpawnTimer = setInterval(createPoliceStanding, 12000);
    foodSpawnTimer = setInterval(createFood, 1800);
    medkitSpawnTimer = setInterval(createMedkit, 9000);
    bonusSpawnTimer = setInterval(createBonus, 15000);
    policeCarSpawnTimer = setInterval(createPoliceCar, 25000);
  }
  function stopSpawning() {
    clearInterval(pedestrianSpawnTimer);
    clearInterval(standingPedSpawnTimer);
    clearInterval(policeStandingSpawnTimer);
    clearInterval(foodSpawnTimer);
    clearInterval(medkitSpawnTimer);
    clearInterval(bonusSpawnTimer);
    clearInterval(policeCarSpawnTimer);
  }

  function checkUpcomingThreat() {
    if (gameOverFlag) return;

    const now = Date.now();
    if (now - lastSpeechTime < speechCooldown) return;

    const courierRect = courier.getBoundingClientRect();
    const thresholdMin = courierRect.right + 50;
    const thresholdMax = courierRect.right + 300;

    for (const p of pedestrians) {
      const pRect = p.elem.getBoundingClientRect();
      if (p.lane === courierLane && pRect.left >= thresholdMin && pRect.left <= thresholdMax) {
        showSpeechRandom(pedestrianPhrases);
        lastSpeechTime = now;
        return;
      }
    }
    for (const p of standingPeds) {
      const pRect = p.elem.getBoundingClientRect();
      if (p.lane === courierLane && pRect.left >= thresholdMin && pRect.left <= thresholdMax) {
        showSpeechRandom(pedestrianPhrases);
        lastSpeechTime = now;
        return;
      }
    }
    for (const p of policeStandings) {
      const pRect = p.elem.getBoundingClientRect();
      if (p.lane === courierLane && pRect.left >= thresholdMin && pRect.left <= thresholdMax) {
        showSpeechRandom(policePhrases);
        lastSpeechTime = now;
        return;
      }
    }
    for (const p of policeCars) {
      const pRect = p.elem.getBoundingClientRect();
      if (p.lane === courierLane && pRect.left >= thresholdMin && pRect.left <= thresholdMax) {
        showSpeechRandom(policePhrases);
        lastSpeechTime = now;
        return;
      }
    }
  }

  // Обновляем длительность анимации полос в зависимости от скорости
  function updateDashSpeed() {
    // speedX от 3/4 до maxSpeedX -> duration от 1.5 до 0.5 сек
    const minDuration = 0.5;
    const maxDuration = 1.5;
    const baseSpeed = isMobile ? 3 : 4;
    const duration = maxDuration - ((speedX - baseSpeed) / (maxSpeedX - baseSpeed)) * (maxDuration - minDuration);
    lanes.forEach(lane => {
      lane.style.animationDuration = duration + 's';
    });
  }

  function gameTick(timestamp) {
    if (!lastFrameTime) lastFrameTime = timestamp;
    const delta = (timestamp - lastFrameTime) / 16.67; // примерно количество кадров (1 кадр = 16.67мс)
    lastFrameTime = timestamp;

    if (!paused && !gameOverFlag) {
      checkUpcomingThreat();

      if (moveCooldown > 0) {
        moveCooldown -= delta * 16.67;
      }
      if (moveCooldown <= 0) {
        if (movingUp && courierTargetLane > 0) {
          courierTargetLane--;
          moveCooldown = 200;
        } else if (movingDown && courierTargetLane < 4) {
          courierTargetLane++;
          moveCooldown = 200;
        }
      }

      updateCourierPositionSmooth();

      updateObjects(delta);

      checkCollisions();

      if (gameTime % 10 === 0 && speedX < maxSpeedX) {
        speedX += 0.015; // чуть медленнее рост скорости
        if (speedX > maxSpeedX) speedX = maxSpeedX;
        updateDashSpeed();
      }
    }

    requestAnimationFrame(gameTick);
  }

  function startTimer() {
    timerInterval = setInterval(() => {
      gameTime++;
      document.getElementById('timer').textContent = gameTime;
    }, 1000);
  }
  function stopTimer() {
    clearInterval(timerInterval);
  }

  function startGame() {
    pedestrians.forEach(p => p.elem.remove());
    standingPeds.forEach(p => p.elem.remove());
    policeStandings.forEach(p => p.elem.remove());
    foods.forEach(f => f.elem.remove());
    medkits.forEach(m => m.elem.remove());
    bonuses.forEach(b => b.elem.remove());
    policeCars.forEach(p => p.elem.remove());
    pedestrians = [];
    standingPeds = [];
    policeStandings = [];
    foods = [];
    medkits = [];
    bonuses = [];
    policeCars = [];
    
    // Запускаем фоновую музыку
    initAudioContext();
    setTimeout(() => playBackgroundMusic(), 500);

    score = 0;
    lives = 3;
    gameTime = 0;
    comboCount = 0;
    speedX = isMobile ? 3 : 4;
    shieldActive = false;
    speedBoostActive = false;
    updateLivesDisplay();
    updateScoreDisplay();
    lifeCountElem.textContent = lives.toFixed(1);
    document.getElementById('timer').textContent = gameTime;
    gameOverFlag = false;
    paused = false;
    container.style.display = 'flex';
    info.style.display = 'block';
    livesElem.style.display = 'block';
    touchControls.style.display = isMobile ? 'flex' : 'none';
    recalcLanes();

    courierLane = 2;
    courierTargetLane = 2;
    courierCurrentY = lanePositions[courierLane] - courier.offsetHeight / 2;
    courier.style.top = courierCurrentY + 'px';

    updateDashSpeed();

    startSpawning();
    startTimer();

    lastFrameTime = 0;
    if (gameLoopId) cancelAnimationFrame(gameLoopId);
    gameLoopId = requestAnimationFrame(gameTick);
  }
  function stopGame() {
    cancelAnimationFrame(gameLoopId);
    stopSpawning();
    stopTimer();
    stopBackgroundMusic();
    pedestrians.forEach(p => p.elem.remove());
    standingPeds.forEach(p => p.elem.remove());
    policeStandings.forEach(p => p.elem.remove());
    foods.forEach(f => f.elem.remove());
    medkits.forEach(m => m.elem.remove());
    bonuses.forEach(b => b.elem.remove());
    policeCars.forEach(p => p.elem.remove());
    pedestrians = [];
    standingPeds = [];
    policeStandings = [];
    foods = [];
    medkits = [];
    bonuses = [];
    policeCars = [];
    touchControls.style.display = 'none';
    movingUp = false;
    movingDown = false;
    moveCooldown = 0;
  }

  function showGameOverAnimation() {
    container.style.display = 'none';
    info.style.display = 'none';
    livesElem.style.display = 'none';
    gameOverMenu.style.display = 'none';

    gtaGameOverScreen.style.display = 'flex';

    gtaGameOverScreen.style.animation = 'none';
    void gtaGameOverScreen.offsetWidth;
    gtaGameOverScreen.style.animation = 'gtaFadeInOut 5s forwards';

    setTimeout(() => {
      gtaGameOverScreen.style.display = 'none';
      finalScoreElem.textContent = Math.floor(score);
      gameOverMenu.style.display = 'block';
    }, 5000);
  }
  function gameOver() {
    if (gameOverFlag) return;
    gameOverFlag = true;
    stopGame();
    stopBackgroundMusic();
    playSound('gameOver');

    showGameOverAnimation();
  }

  // Обработчики меню
  playBtn.addEventListener('click', () => {
    mainMenu.style.display = 'none';
    startGame();
  });
  rulesBtn.addEventListener('click', () => {
    mainMenu.style.display = 'none';
    rulesDialog.style.display = 'block';
  });
  exitBtn.addEventListener('click', () => {
    mainMenu.style.display = 'none';
    container.style.display = 'none';
    info.style.display = 'none';
    livesElem.style.display = 'none';
    gameOverMenu.style.display = 'none';
    rulesDialog.style.display = 'none';
    gtaGameOverScreen.style.display = 'none';
    touchControls.style.display = 'none';
    stopGame();

    // Отправляем сообщение родительскому окну для закрытия модального окна
    window.parent.postMessage('closeGame', '*');

    setTimeout(() => {
      if (!window.closed) {
        // Проверяем, если мы в iframe или родительском окне
        if (window.parent !== window.self) {
          // Мы в iframe, закрываем модальное окно
          window.parent.postMessage('closeGame', '*');
        } else {
          // Мы в отдельной вкладке, возвращаемся на главную страницу
          window.location.href = window.location.origin;
        }
      }
    }, 500);
  });
  closeRulesBtn.addEventListener('click', () => {
    rulesDialog.style.display = 'none';
    mainMenu.style.display = 'block';
  });
  restartBtn.addEventListener('click', () => {
    gameOverMenu.style.display = 'none';
    startGame();
  });
  toMenuBtn.addEventListener('click', () => {
    gameOverMenu.style.display = 'none';
    mainMenu.style.display = 'block';
  });
  becomeBtn.addEventListener('click', () => {
    const referralLink = 'https://reg.eda.yandex.ru/?advertisement_campaign=forms_for_agents&user_invite_code=f123426cfad648a1afadad700e3a6b6b&utm_content=blank';
    window.open(referralLink, '_blank');
  });

  // Сенсорное управление
  btnUp.addEventListener('touchstart', e => { e.preventDefault(); if (!gameOverFlag && !paused) movingUp = true; });
  btnUp.addEventListener('touchend', e => { e.preventDefault(); movingUp = false; });
  btnDown.addEventListener('touchstart', e => { e.preventDefault(); if (!gameOverFlag && !paused) movingDown = true; });
  btnDown.addEventListener('touchend', e => { e.preventDefault(); movingDown = false; });

  // Клавиатура
  window.addEventListener('keydown', e => {
    if (gameOverFlag || paused) return;
    if (e.key === 'ArrowUp' || e.key === 'w') movingUp = true;
    else if (e.key === 'ArrowDown' || e.key === 's') movingDown = true;
  });
  window.addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') movingUp = false;
    else if (e.key === 'ArrowDown' || e.key === 's') movingDown = false;
  });

  // При загрузке страницы показываем приветственный экран 5 секунд, потом меню
  window.addEventListener('load', () => {
    setTimeout(() => {
      welcomeScreen.style.display = 'none';
      mainMenu.style.display = 'block';
    }, 5000);
  });

  // Пересчёт полос при изменении размера окна
  window.addEventListener('resize', () => {
    if (!gameOverFlag) recalcLanes();
  });
})();
</script>

</body>
</html>